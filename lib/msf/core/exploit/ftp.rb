module Msf

require 'msf/core/exploit/tcp'

###
#
# This module exposes methods that may be useful to exploits that deal with
# servers that speak the File Transfer Protocol (FTP).
#
###
module Exploit::Remote::Ftp

	include Exploit::Remote::Tcp
	
	def initialize(info = {})
		super

		# Register the options that all FTP exploits may make use of.
		register_options(
			[
				Opt::RHOST,
				Opt::RPORT(21),
				OptString.new('USER', [ false, 'The username to authenticate as' ]),
				OptString.new('PASS', [ false, 'The password for the specified username' ])
			], Msf::Exploit::Remote::Ftp)
	end

	#
	# This method establishes an FTP connection to host and port specified by
	# the RHOST and RPORT options, respectively.  After connecting, the banner
	# message is read in and stored in the 'banner' attribute.
	#
	def connect(global = true)
		print_status("Connecting to FTP server #{rhost}:#{rport}...")

		fd = super
	
		# Wait for a banner to arrive...
		self.banner = fd.get(5)

		print_status("Connected to target FTP server.")
	
		# Return the file descriptor to the caller
		fd
	end

	#
	# Connect and login to the remote FTP server using the credentials 
	# that have been supplied in the exploit options.
	#
	def connect_login(global = true)
		ftpsock = connect(global)

		# If the user supplied a username, send that
		if (user)
			print_status("Sending username #{user}...")

			send_user(user, ftpsock)

			# If the user supplied a password, send that
			if (pass)
				print_status("Sending password...")

				send_pass(pass, ftpsock)
			end
		end
	end

	#
	# This method logs in as the supplied user by transmitting the FTP
	# 'USER <user>' command.
	#
	def send_user(user, nsock = self.sock)
		raw_send("USER #{user}\n", nsock)
	end

	#
	# This method completes user authentication by sending the supplied
	# password using the FTP 'PASS <pass>' command.
	#
	def send_pass(pass, nsock = self.sock)
		raw_send("PASS #{pass}\n", nsock)
	end

	#
	# This method transmits an FTP command and waits for a response.  If one is
	# received, it is returned to the caller.
	#
	def raw_send(cmd, nsock = self.sock)
		nsock.put(cmd)
		nsock.get
	end

	##
	#
	# Wrappers for getters
	#
	##

	#
	# Returns the user string from the 'USER' option.
	#
	def user
		datastore['USER']
	end

	#
	# Returns the user string from the 'PASS' option.
	#
	def pass
		datastore['PASS']
	end

protected

	#
	# This attribute holds the banner that was read in after a successful call
	# to connect or connect_login.
	#
	attr_accessor :banner

end

end
