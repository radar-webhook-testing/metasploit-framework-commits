require 'msf/base'

module Msf
module Simple

###
#
# A simplified exploit wrapper.
#
###
module Exploit

	include Module

	#
	# Wraps the exploitation process
	#
	def self.exploit_simple(exploit, opts)
		target_idx = opts['Target'] || exploit.default_target

		# Make sure parameters are valid.
		if (opts['Payload'] == nil)
			raise MissingPayloadError, 
				"You must specify a payload.", caller
		end

		if (target_idx == nil or target_idx < 0)
			raise MissingTargetError,
				"You must select a target.", caller
		end

		# Start it up
		driver = ExploitDriver.new(exploit.framework)

		# Initialize the driver instance
		driver.exploit    = exploit
		driver.target_idx = target_idx
		driver.payload    = exploit.framework.modules.create(opts['Payload'])

		# Set the force wait for session flag if the caller requested force
		# blocking.  This is so that passive exploits can be blocked on from
		# things like the cli.
		driver.force_wait_for_session = true if (opts['ForceBlocking'] == true)

		# Was the payload valid?
		if (driver.payload == nil)
			raise MissingPayloadError,
				"You specified an invalid payload: #{opts['Payload']}", caller
		end

		# Force the payload to share the exploit's datastore
		driver.payload.share_datastore(driver.exploit.datastore)

		# Set the payload and exploit's subscriber values
		driver.exploit.init_ui(opts['LocalInput'], opts['LocalOutput'])
		driver.payload.init_ui(opts['LocalInput'], opts['LocalOutput'])

		if (opts['RunAsJob'])
			driver.use_job = true
		end

		# Let's rock this party
		session = driver.run

		return session
	end

	#
	# Calls the class method
	#
	def exploit_simple(opts)
		Msf::Simple::Exploit.exploit_simple(self, opts)
	end

end

end
end
