#!/usr/bin/env ruby

$:.unshift(File.join(File.dirname(__FILE__), 'lib'))

require 'rex/peparsey'
require 'rex/arch/x86'
require 'optparse'

#
# Right now this program is a bit shakey...
#
# - It tries to error on the side of caution, so it will try for a
#   false negative vs a false positive.
# - It doesn't account for the entire PE image neccesairly
# - It wouldn't find hits that overlap sections
# - etc etc
#

class JmpRegScanner
	attr_accessor :regex

	def initialize(regnums)
		# build a list of the call bytes
		calls  = _build_byte_list(0xd0, regnums - [4]) # note call esp's don't work..
		jmps   = _build_byte_list(0xe0, regnums)
		pushs1 = _build_byte_list(0x50, regnums)
		pushs2 = _build_byte_list(0xf0, regnums)

		regexstr = '('
		if !calls.empty?
			regexstr += "\xff[#{calls}]|"
		end

		regexstr += "\xff[#{jmps}]|([#{pushs1}]|\xff[#{pushs2}])(\xc3|\xc2..))"

		self.regex = Regexp.new(regexstr)
	end

	# build a list for regex of the possible bytes, based on a base
	# byte and a list of register numbers..
	def _build_byte_list(base, regnums)
		regnums.collect { |regnum| Regexp.escape((base | regnum).chr) }.join('')
	end

	def _ret_size(section, index)
		case section.read(index, 1)
			when "\xc3"
				return 1
			when "\xc2"
				return 3
		end

		raise "wtf"
	end

	def _parse_ret(data)
		if data.length == 1
			return "ret"
		else
			return "retn 0x%04x" % data[1, 2].unpack('v')[0]
		end
	end


	def scan_section(section)
		index = 0

		hits  = [ ]

		while (index = section.index(regex, index)) != nil
			rva     = section.offset_to_rva(index)
			message = ''

			parse_ret = false

			byte1 = section.read(index, 1)[0]

			if byte1 == 0xff
				byte2   = section.read(index+1, 1)[0]
				regname = Rex::Arch::X86.reg_name32(byte2 & 0x7)

				case byte2 & 0xf8
				when 0xd0
					message = "call #{regname}"
					index += 2
				when 0xe0
					message = "jmp #{regname}"
					index += 2
				when 0xf0
					retsize = _ret_size(section, index+2)
					message = "push #{regname}; " + _parse_ret(section.read(index+2, retsize))
					index += 2 + retsize
				else
					raise "wtf"
				end
			else 
				regname = Rex::Arch::X86.reg_name32(byte1 & 0x7)
				retsize = _ret_size(section, index+1)
				message = "push #{regname}; " + _parse_ret(section.read(index+1, retsize))
				index += 1 + retsize
			end

			hits << [ rva, message ]
		end

		return hits
	end
end

class PopPopRetScanner < JmpRegScanner

	def initialize
		pops = _build_byte_list(0x58, (0 .. 7).to_a - [4]) # we don't want pop esp's...

		self.regex = Regexp.new("[#{pops}][#{pops}](\xc3|\xc2..)")
	end

	def scan_section(section)
		index = 0

		hits  = [ ]

		while index < section.size && (index = section.index(regex, index)) != nil
			rva     = section.offset_to_rva(index)
			message = ''
			
			pops = section.read(index, 2)
			reg1 = Rex::Arch::X86.reg_name32(pops[0] & 0x7)
			reg2 = Rex::Arch::X86.reg_name32(pops[1] & 0x7)

			message = "pop #{reg1}; pop #{reg2}; "

			retsize = _ret_size(section, index+2)
			message += _parse_ret(section.read(index+2, retsize))

			index += 2 + retsize

			hits << [ rva, message ]
		end

		return hits
	end
end



opt = OptionParser.new

opt.banner = 'Usage: [options] [files]'
opt.separator('')
opt.separator('Options:')

scanner  = nil
pe_klass = Rex::PeParsey::Pe

opt.on('-j', '--jump [REG]', 'Find a jmp/call REG') do |t|
	# take csv of register names (like eax,ebx) and convert
	# them to an array of register numbers
	regnums = t.split(',').collect { |o| Rex::Arch::X86.reg_number(o) }
	scanner = JmpRegScanner.new(regnums)
end
opt.on('-p', '--poppopret', 'Find a pop/pop/ret') do |t|
	scanner = PopPopRetScanner.new
end
opt.on('-m', '--memdump', 'The files are memdump.exe images') do |t|
	pe_klass = Rex::PeParsey::PeMemDump
end

opt.parse!

ARGV.each do |file|
	begin
		pe = pe_klass.new_from_file(file, true)
	rescue Rex::PeParsey::FileHeaderError
		next if $!.message == "Couldn't find the PE magic!"
		raise $!
	end

	pe.all_sections.each do |section|
		hits = scanner.scan_section(section)
		hits.each do |hit|
			vma  = pe.rva_to_vma(hit[0])
			msg  = hit[1]
			puts "0x%08x %s" % [ vma, msg ]
		end
	end

	pe.close

end
